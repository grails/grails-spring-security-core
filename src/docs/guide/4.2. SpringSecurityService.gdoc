@grails.plugins.springsecurity.SpringSecurityService@ provides security utility functions. It's a regular Grails service, so you can use dependency injection to inject it into a controller, service, taglib, etc.:

{code}
def springSecurityService
{code}

h4. isLoggedIn()

Checks to see if there's a currently logged-in user.

Example:

{code}
class SomeController {

   def springSecurityService

   def someAction = {
      if (springSecurityService.isLoggedIn()) {
         ...
      }
      else {
         ...
      }
   }
}
{code}

h4. getAuthentication()

Retrieves the current user's [Authentication|http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/Authentication.html] if logged in, or @null@ otherwise.

Example:

{code}
class SomeController {

   def springSecurityService

   def someAction = {
      def auth = springSecurityService.authentication
      String username = auth.username
      def authorities = auth.authorities // a Collection of GrantedAuthority
      boolean authenticated = auth.authenticated
      ...
   }
}
{code}

h4. getPrincipal()

Retrieves the currently logged in user's @Principal@, or @null@ if not logged in. This will be a Spring Security [User|http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/userdetails/User.html] unless you've created a custom @UserDetailsService@, in which case it'll be whatever implementation of [UserDetails|http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/userdetails/UserDetails.html] you use there.

Example:

{code}
class SomeController {

   def springSecurityService

   def someAction = {
      def principal = springSecurityService.principal
      String username = principal.username
      def authorities = principal.authorities // a Collection of GrantedAuthority
      boolean enabled = principal.enabled
      ...
   }
}
{code}

h4. encodePassword()

Encrypts a password using the configured encryption scheme. By default the plugin uses SHA-256, but this is configurable using the @grails.plugins.springsecurity.password.algorithm@ attribute in @Config.groovy@. You can use any message digest algorithm that's supported in your JDK; see [this page|http://java.sun.com/j2se/1.5.0/docs/guide/security/CryptoSpec.html#AppA] for information on what's available. In particular you are *strongly* discouraged from using MD5 or SHA-1 algorithms since they are rather weak and have well-known vulnerabilities. You should also use a salt for your passwords, which greatly increases the computational complexity of decrypting passwords if your database gets compromised. See [here|guide:10.5. Salted passwords] for details on using salted passwords.

Example:

{code}
class PersonController {

   def springSecurityService

   def updateAction = {
      def person = Person.get(params.id)

      params.salt = person.salt
      if (person.password != params.password) {
         params.password = springSecurityService.encodePassword(password, salt)
         def salt = ... // e.g. randomly generated using some utility method
         params.salt = salt
      }
      person.properties = params
      if (!person.save(flush: true)) {
         render view: 'edit', model: [person: person]
         return
      }
      redirect action: show, id: person.id
   }
}
{code}

h4. updateRole()

Updates a role and if you're using @Requestmap@ instances to manage securing URLs, will replace the new role name in all @Requestmap@ definitions that use it if the name was changed.

Example:

{code}
class RoleController {

   def springSecurityService

   def update = {
      def roleInstance = Role.get(params.id)
      if (!springSecurityService.updateRole(roleInstance, params)) {
         render view: 'edit', model: [roleInstance: roleInstance]
         return
      }

      flash.message = "The role was updated"
      redirect action: show, id: roleInstance.id
   }
}
{code}

h4. deleteRole()

Deletes a role and if you're using @Requestmap@ instances to manage securing URLs, will remove the role from all @Requestmap@ definitions. If a @Requestmap@'s config attribute is just this role's name (e.g. "/foo/bar/**=ROLE_FOO") it will be deleted.

Example:

{code}
class RoleController {

   def springSecurityService

   def delete = {
      def roleInstance = Role.get(params.id)
      try {
         springSecurityService.deleteRole (roleInstance
         flash.message = "The role was deleted"
         redirect action: list
      }
      catch (DataIntegrityViolationException e) {
         flash.message = "Unable to delete the role"
         redirect action: show, id: params.id
      }
   }
}
{code}

h4. clearCachedRequestmaps()

If you're using @Requestmap@ instances to manage securing URLs, the plugin will load and cache all @Requestmap@ instances as a performance optimization. This saves a lot of database activity since the requestmaps are checked for each request. But you can't allow the cache to become stale, so when you create, edit or delete a @Requestmap@ you should flush the cache to trigger a complete reload. Both @updateRole()@ and @deleteRole()@ call this method for you, so you should call this when you create a new @Requestmap@ or if you do some other @Requestmap@ work that would affect the cache.

Example:

{code}
class RequestmapController {

   def springSecurityService

   def save = {
      def requestmapInstance = new Requestmap(params)
      if (!requestmapInstance.save(flush: true)) {
         render view: 'create', model: [requestmapInstance: requestmapInstance]
         return
      }

      springSecurityService.clearCachedRequestmaps()
      flash.message = "Requestmap created"
      redirect action: show, id: requestmapInstance.id
   }
}
{code}

h4. reauthenticate()

Rebuilds an [Authentication|http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/Authentication.html] for the given username and registers it in the security context. This is typically used after updating a user's authorities or other data that is cached in the @Authentication@ or @Principal@. It slso removes the user from the user cache to force a refresh at next login.

Example:

{code}
class UserController {

   def springSecurityService

   def update = {
      def userInstance = User.get(params.id)

      params.salt = person.salt
      if (userInstance.password != params.password) {
         params.password = springSecurityService.encodePassword(params.password, salt)
         def salt = ... // e.g. randomly generated using some utility method
         params.salt = salt
      }
      userInstance.properties = params
      if (!userInstance.save(flush: true)) {
         render view: 'edit', model: [userInstance: userInstance]
         return
      }

      if (springSecurityService.loggedIn &&
             springSecurityService.principal.username == userInstance.username) {
         springSecurityService.reauthenticate userInstance.username
      }

      flash.message = "The user was updated"
      redirect action: show, id: userInstance.id
   }
}
{code}

